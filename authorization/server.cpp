#include "server.h"
#include "auth.h"
#include "config.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <sstream>
#include <regex>

using namespace std;

#pragma comment(lib, "ws2_32.lib")

void sendResponse(int client, const string& content, bool json = false) {
    string response = "HTTP/1.1 200 OK\r\n";
    response += "Content-Type: " + string(json ? "application/json" : "text/html; charset=utf-8") + "\r\n";
    response += "Access-Control-Allow-Origin: *\r\n";
    response += "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n";
    response += "Access-Control-Allow-Headers: Content-Type\r\n";
    response += "Connection: close\r\n";
    response += "\r\n" + content;
    
    send(client, response.c_str(), response.length(), 0);
}

void sendError(int client, const string& error, int code = 400) {
    string response = "HTTP/1.1 " + to_string(code) + " " + 
                     (code == 401 ? "Unauthorized" : "Bad Request") + "\r\n";
    response += "Content-Type: application/json\r\n";
    response += "Connection: close\r\n\r\n";
    response += "{\"error\":\"" + error + "\"}";
    
    send(client, response.c_str(), response.length(), 0);
}

string readRequest(int client) {
    char buffer[8192] = {0};  // –£–≤–µ–ª–∏—á–∏–ª –±—É—Ñ–µ—Ä
    int bytes = recv(client, buffer, sizeof(buffer), 0);
    if (bytes <= 0) return "";
    return string(buffer, bytes);
}

map<string, string> parseFormData(const string& body) {
    map<string, string> params;
    istringstream iss(body);
    string pair;
    
    while (getline(iss, pair, '&')) {
        size_t eq = pair.find('=');
        if (eq != string::npos) {
            string key = pair.substr(0, eq);
            string value = pair.substr(eq + 1);
            // –ü—Ä–æ—Å—Ç–æ–π URL decode
            string decoded;
            for (size_t i = 0; i < value.length(); ++i) {
                if (value[i] == '%' && i + 2 < value.length()) {
                    int hex;
                    sscanf(value.substr(i + 1, 2).c_str(), "%x", &hex);
                    decoded += (char)hex;
                    i += 2;
                } else if (value[i] == '+') {
                    decoded += ' ';
                } else {
                    decoded += value[i];
                }
            }
            params[key] = decoded;
        }
    }
    return params;
}

// ========== –ì–õ–ê–í–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö ==========

void handleClient(int client) {
    string request = readRequest(client);
    if (request.empty()) return;
    
    // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–æ–¥ –∏ –ø—É—Ç—å
    istringstream ss(request);
    string method, path, version;
    ss >> method >> path >> version;
    
    cout << "[" << method << "] " << path << endl;
    
    // ========== CORS PREFLIGHT ==========
    if (method == "OPTIONS") {
        sendResponse(client, "");
        return;
    }
    
    // ========== –ò–ù–§–û –û API ==========
    if (path == "/" || path == "/api" || path == "/auth") {
        string apiInfo = R"({
    "service": "Authentication Module",
    "version": "1.0",
    "description": "This is a pure API module for user authentication",
    "endpoints": {
        "register": {"method": "POST", "path": "/auth/register", "desc": "Register new user"},
        "login": {"method": "POST", "path": "/auth/login", "desc": "Login with credentials"},
        "oauth_start": {"method": "GET", "path": "/auth/oauth?login_token=TOKEN", "desc": "Start GitHub OAuth"},
        "oauth_callback": {"method": "GET", "path": "/auth/callback?code=CODE&state=STATE", "desc": "GitHub OAuth callback"},
        "verify": {"method": "GET", "path": "/auth/verify?token=TOKEN", "desc": "Verify JWT token"},
        "refresh": {"method": "POST", "path": "/auth/refresh", "desc": "Refresh access token"},
        "telegram": {"method": "POST", "path": "/auth/telegram", "desc": "Telegram bot authentication"}
    },
    "note": "All responses are in JSON format. No HTML is generated by this module."
})";
        sendResponse(client, apiInfo, true);
        return;
    }
    
    // ========== –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø ==========
    if (path == "/auth/register" && method == "POST") {
        size_t body_start = request.find("\r\n\r\n");
        if (body_start == string::npos) {
            sendError(client, "Missing request body");
            return;
        }
        
        string body = request.substr(body_start + 4);
        auto params = parseFormData(body);
        
        string login = params["login"];
        string password = params["password"];
        string fullname = params["fullname"];
        string email = params["email"];
        
        if (login.empty() || password.empty() || fullname.empty() || email.empty()) {
            sendError(client, "All fields are required");
            return;
        }
        
        string result = Auth::registerUser(login, password, fullname, email);
        sendResponse(client, result, true);
        return;
    }
    
    // ========== –ê–í–¢–û–†–ò–ó–ê–¶–ò–Ø ==========
    if (path == "/auth/login" && method == "POST") {
        size_t body_start = request.find("\r\n\r\n");
        if (body_start == string::npos) {
            sendError(client, "Missing request body");
            return;
        }
        
        string body = request.substr(body_start + 4);
        auto params = parseFormData(body);
        
        string login = params["login"];
        string password = params["password"];
        
        if (login.empty() || password.empty()) {
            sendError(client, "Login and password required");
            return;
        }
        
        string result = Auth::loginUser(login, password);
        sendResponse(client, result, true);
        return;
    }
    
    // ========== –°–¢–ê–†–¢ OAUTH ==========
    if (path.find("/auth/oauth?") == 0) {
        size_t token_pos = path.find("login_token=");
        if (token_pos != string::npos) {
            string token = path.substr(token_pos + 12);
            // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞
            size_t amp_pos = token.find('&');
            if (amp_pos != string::npos) {
                token = token.substr(0, amp_pos);
            }
            
            string result = Auth::startOAuth(token);
            sendResponse(client, result, true);
        } else {
            sendError(client, "Missing login_token parameter");
        }
        return;
    }
    
    // ========== CALLBACK GITHUB ==========
    if (path.find("/auth/callback?") == 0) {
        regex param_regex("code=([^&]+)&state=([^&\\s]+)");
        smatch matches;
        
        if (regex_search(path, matches, param_regex) && matches.size() == 3) {
            string code = matches[1];
            string state = matches[2];
            
            string result = Auth::handleGitHubCallback(code, state);
            sendResponse(client, result, true);
        } else {
            // –ü–æ–ø—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥
            size_t code_pos = path.find("code=");
            size_t state_pos = path.find("&state=");
            
            if (code_pos != string::npos) {
                string code, state;
                
                if (state_pos != string::npos) {
                    code = path.substr(code_pos + 5, state_pos - (code_pos + 5));
                    state = path.substr(state_pos + 7);
                    size_t end_pos = state.find('&');
                    if (end_pos != string::npos) {
                        state = state.substr(0, end_pos);
                    }
                } else {
                    code = path.substr(code_pos + 5);
                    state = "";
                }
                
                string result = Auth::handleGitHubCallback(code, state);
                sendResponse(client, result, true);
            } else {
                sendError(client, "Invalid callback parameters");
            }
        }
        return;
    }
    
    // ========== –¢–ï–õ–ï–ì–†–ê–ú AUTH ==========
    if (path == "/auth/telegram" && method == "POST") {
        size_t body_start = request.find("\r\n\r\n");
        if (body_start == string::npos) {
            sendError(client, "Missing request body");
            return;
        }
        
        string body = request.substr(body_start + 4);
        auto params = parseFormData(body);
        
        string telegram_id = params["telegram_id"];
        string name = params["name"];
        
        if (telegram_id.empty() || name.empty()) {
            sendError(client, "telegram_id and name required");
            return;
        }
        
        string result = Auth::telegramAuth(telegram_id, name);
        sendResponse(client, result, true);
        return;
    }
    
    // ========== VERIFY TOKEN ==========
    if (path.find("/auth/verify?") == 0) {
        size_t token_pos = path.find("token=");
        if (token_pos != string::npos) {
            string token = path.substr(token_pos + 6);
            // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞
            size_t amp_pos = token.find('&');
            if (amp_pos != string::npos) {
                token = token.substr(0, amp_pos);
            }
            
            string result = Auth::verifyToken(token);
            sendResponse(client, result, true);
        } else {
            sendError(client, "Missing token parameter");
        }
        return;
    }
    
    // ========== REFRESH TOKEN ==========
    if (path == "/auth/refresh" && method == "POST") {
        size_t body_start = request.find("\r\n\r\n");
        if (body_start == string::npos) {
            sendError(client, "Missing request body");
            return;
        }
        
        string body = request.substr(body_start + 4);
        auto params = parseFormData(body);
        
        string refresh_token = params["refresh_token"];
        
        if (refresh_token.empty()) {
            sendError(client, "refresh_token required");
            return;
        }
        
        string result = Auth::refreshToken(refresh_token);
        sendResponse(client, result, true);
        return;
    }
    
    // ========== –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–ê–†–´–• –≠–ù–î–ü–û–ò–ù–¢–û–í (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏) ==========
    if (path == "/api/telegram" && method == "POST") {
        // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –Ω–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç
        size_t body_start = request.find("\r\n\r\n");
        if (body_start != string::npos) {
            string body = request.substr(body_start + 4);
            auto params = parseFormData(body);
            
            string telegram_id = params["telegram_id"];
            string name = params["name"];
            
            if (!telegram_id.empty() && !name.empty()) {
                string result = Auth::telegramAuth(telegram_id, name);
                sendResponse(client, result, true);
            } else {
                sendError(client, "Missing parameters");
            }
        }
        return;
    }
    
    if (path.find("/api/verify?") == 0) {
        // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –Ω–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç
        size_t token_pos = path.find("token=");
        if (token_pos != string::npos) {
            string token = path.substr(token_pos + 6);
            size_t amp_pos = token.find('&');
            if (amp_pos != string::npos) {
                token = token.substr(0, amp_pos);
            }
            
            string result = Auth::verifyToken(token);
            sendResponse(client, result, true);
        } else {
            sendError(client, "Missing token parameter");
        }
        return;
    }
    
    // ========== –í–°–ï –û–°–¢–ê–õ–¨–ù–´–ï –ó–ê–ü–†–û–°–´ ==========
    sendError(client, "Endpoint not found", 404);
}

void HttpServer::start(int port) {
    WSADATA wsa;
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        cerr << "–û—à–∏–±–∫–∞ WSAStartup" << endl;
        return;
    }
    
    SOCKET server = socket(AF_INET, SOCK_STREAM, 0);
    if (server == INVALID_SOCKET) {
        cerr << "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–∫–µ—Ç–∞" << endl;
        WSACleanup();
        return;
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–ø—Ü–∏—é –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–æ—Ä—Ç–∞
    int opt = 1;
    setsockopt(server, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));
    
    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);
    
    if (bind(server, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {
        cerr << "–û—à–∏–±–∫–∞ bind: " << WSAGetLastError() << endl;
        closesocket(server);
        WSACleanup();
        return;
    }
    
    if (listen(server, 10) == SOCKET_ERROR) {
        cerr << "–û—à–∏–±–∫–∞ listen" << endl;
        closesocket(server);
        WSACleanup();
        return;
    }
    
    cout << "\n==========================================" << endl;
    cout << "üöÄ –ú–æ–¥—É–ª—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!" << endl;
    cout << "üìç –ü–æ—Ä—Ç: " << port << endl;
    cout << "üåê URL: http://localhost:" << port << endl;
    cout << "\nüì° –î–æ—Å—Ç—É–ø–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã:" << endl;
    cout << "   POST /auth/register    - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è" << endl;
    cout << "   POST /auth/login       - –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è" << endl;
    cout << "   GET  /auth/oauth       - –°—Ç–∞—Ä—Ç OAuth" << endl;
    cout << "   GET  /auth/callback    - GitHub callback" << endl;
    cout << "   POST /auth/telegram    - Telegram auth" << endl;
    cout << "   GET  /auth/verify      - –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞" << endl;
    cout << "   POST /auth/refresh     - –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞" << endl;
    cout << "\n‚úÖ –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ —Å –¥—Ä—É–≥–∏–º–∏ –º–æ–¥—É–ª—è–º–∏!" << endl;
    cout << "==========================================\n" << endl;
    
    while (true) {
        SOCKET client = accept(server, nullptr, nullptr);
        if (client != INVALID_SOCKET) {
            handleClient(client);
            closesocket(client);
        }
    }
    
    closesocket(server);
    WSACleanup();
}