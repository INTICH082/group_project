import asyncio
import logging
import os
import json
import secrets
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from functools import wraps
from enum import Enum

from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ParseMode

import redis.asyncio as redis
from dotenv import load_dotenv

# =========================
# ENV
# =========================
load_dotenv()
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379/0")

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
logger = logging.getLogger("telegram-bot")

# =========================
# BOT
# =========================
bot = Bot(token=BOT_TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher()


# =========================
# USER STATUS
# =========================
class UserStatus(str, Enum):
    UNKNOWN = "unknown"
    ANONYMOUS = "anonymous"
    AUTHORIZED = "authorized"


# =========================
# STATISTICS
# =========================
class Statistics:
    def __init__(self):
        self.commands_count = 0
        self.active_users = set()

    def increment_commands(self):
        self.commands_count += 1

    def add_active_user(self, user_id: int):
        self.active_users.add(user_id)

    def remove_active_user(self, user_id: int):
        self.active_users.discard(user_id)

    def get_active_users_count(self):
        return len(self.active_users)


stats = Statistics()


# =========================
# SIMPLE REDIS
# =========================
class SimpleRedis:
    def __init__(self):
        self.data = {}
        self.connected = False

    async def connect(self):
        try:
            self.client = redis.from_url(REDIS_URL, decode_responses=True, socket_connect_timeout=2)
            await self.client.ping()
            self.connected = True
            logger.info("‚úÖ Redis –ø–æ–¥–∫–ª—é—á–µ–Ω")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Redis –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}. –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.")
            self.connected = False

    async def get(self, key: str) -> Optional[str]:
        try:
            if self.connected:
                return await self.client.get(key)
        except:
            pass
        return json.dumps(self.data.get(key)) if key in self.data else None

    async def setex(self, key: str, ttl: int, value: str):
        try:
            if self.connected:
                await self.client.setex(key, ttl, value)
                return
        except:
            pass
        self.data[key] = json.loads(value)

    async def delete(self, key: str):
        try:
            if self.connected:
                await self.client.delete(key)
        except:
            pass
        if key in self.data:
            del self.data[key]

    async def keys(self, pattern: str) -> List[str]:
        try:
            if self.connected:
                return await self.client.keys(pattern)
        except:
            pass
        import re
        pattern_re = pattern.replace('*', '.*')
        return [k for k in self.data.keys() if re.match(pattern_re, k)]


redis_client = SimpleRedis()


# =========================
# AUTH SERVICE STUB - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô (–±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏)
# =========================
class AuthServiceStub:
    def __init__(self):
        self.login_tokens = {}
        self.codes = {}

    async def generate_login_url(self, login_token: str, provider: str = "code") -> str:
        code = secrets.randbelow(900000) + 100000

        if provider == "code":
            self.codes[code] = login_token

        self.login_tokens[login_token] = {
            "status": "pending",
            "provider": provider,
            "code": code if provider == "code" else None,
            "created_at": datetime.utcnow(),
            "user_agent": "telegram-bot"
        }

        if provider == "github":
            return "https://github.com/login/oauth/authorize"
        elif provider == "yandex":
            return "https://oauth.yandex.ru/authorize"
        else:
            return "https://t.me/cfutgbot"

    async def check_login_token(self, login_token: str) -> Optional[Dict]:
        if login_token not in self.login_tokens:
            return None

        token_data = self.login_tokens[login_token]

        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º pending –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–æ —Ä—É—á–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å Auth Service
        return {"status": token_data["status"]}

    async def simulate_auth_confirmation(self, login_token: str):
        """–ò–º–∏—Ç–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ (–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)"""
        if login_token in self.login_tokens:
            self.login_tokens[login_token]["status"] = "granted"
            return True
        return False


auth_service = AuthServiceStub()


# =========================
# CORE SERVICE STUB
# =========================
class CoreServiceStub:
    async def get_tests(self, access_token: str) -> List[Dict]:
        return [
            {"id": 1, "name": "Python Basics", "description": "–û—Å–Ω–æ–≤—ã –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ Python",
             "questions_count": 10, "active": True},
            {"id": 2, "name": "Async IO", "description": "–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ Python", "questions_count": 8,
             "active": True},
            {"id": 3, "name": "Docker", "description": "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–∞—Ü–∏—è –∏ Docker", "questions_count": 12,
             "active": False},
            {"id": 4, "name": "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö", "description": "SQL –∏ NoSQL –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö", "questions_count": 15,
             "active": True}
        ]

    async def get_user_profile(self, access_token: str, user_id: str) -> Dict:
        return {
            "id": user_id,
            "email": f"user_{user_id[:8]}@example.com",
            "name": "–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤",
            "role": "student",
            "created_at": "2024-01-01T00:00:00",
            "completed_tests": 5,
            "average_score": 85.5
        }


core_service = CoreServiceStub()


# =========================
# DECORATORS
# =========================
async def check_rate_limit(chat_id: int, seconds: int = 2) -> bool:
    return True


def rate_limit(seconds: int = 2):
    def decorator(handler):
        @wraps(handler)
        async def wrapper(message: Message, *args, **kwargs):
            stats.increment_commands()
            return await handler(message, *args, **kwargs)

        return wrapper

    return decorator


def safe_send_message(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}")

    return wrapper


def require_auth():
    def decorator(handler):
        @wraps(handler)
        async def wrapper(event, *args, **kwargs):
            # –ü–æ–ª—É—á–∞–µ–º chat_id –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
            if isinstance(event, Message):
                chat_id = event.chat.id
            elif isinstance(event, CallbackQuery):
                chat_id = event.message.chat.id
            else:
                return

            user = await get_user(chat_id)
            if not user or user.get("status") != UserStatus.AUTHORIZED:
                try:
                    await bot.send_message(
                        chat_id,
                        "‚ùå <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è</b>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /login –¥–ª—è –≤—Ö–æ–¥–∞."
                    )
                except:
                    pass
                return
            return await handler(event, *args, **kwargs)

        return wrapper

    return decorator


# =========================
# USER MANAGEMENT
# =========================
async def get_user(chat_id: int) -> Optional[Dict]:
    data = await redis_client.get(f"user:{chat_id}")
    if data:
        return json.loads(data)
    return None


async def save_user(chat_id: int, data: Dict):
    await redis_client.setex(f"user:{chat_id}", 86400, json.dumps(data))


async def delete_user(chat_id: int):
    await redis_client.delete(f"user:{chat_id}")


async def set_user_anonymous(chat_id: int, login_token: str, provider: str = "code"):
    await save_user(chat_id, {
        "status": UserStatus.ANONYMOUS,
        "login_token": login_token,
        "provider": provider,
        "created_at": datetime.utcnow().isoformat()
    })


async def set_user_authorized(chat_id: int, access_token: str, refresh_token: str, user_id: str, email: str):
    await save_user(chat_id, {
        "status": UserStatus.AUTHORIZED,
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user_id": user_id,
        "email": email,
        "authorized_at": datetime.utcnow().isoformat()
    })
    stats.add_active_user(chat_id)


async def get_user_status(chat_id: int) -> UserStatus:
    user = await get_user(chat_id)
    if not user:
        return UserStatus.UNKNOWN
    return UserStatus(user.get("status", UserStatus.UNKNOWN))


async def get_all_authorized_users() -> List[Dict]:
    users = []
    try:
        keys = await redis_client.keys("user:*")
        for key in keys:
            data = await redis_client.get(key)
            if data:
                user = json.loads(data)
                if user.get("status") == UserStatus.AUTHORIZED:
                    try:
                        chat_id = int(key.split(":")[1])
                        user["chat_id"] = chat_id
                        users.append(user)
                    except:
                        pass
    except Exception as e:
        logger.error(f"Error getting authorized users: {e}")
    return users


# =========================
# COMMAND HANDLERS
# =========================
@dp.message(Command("start"))
@rate_limit()
@safe_send_message
async def cmd_start(message: Message):
    chat_id = message.chat.id
    user = await get_user(chat_id)

    if not user:
        text = f"""
üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {message.from_user.first_name or '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}!</b>

ü§ñ <b>Telegram-–∫–ª–∏–µ–Ω—Ç —Å–∏—Å—Ç–µ–º—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</b>

–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è.

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /login –¥–ª—è –≤—Ö–æ–¥–∞ –≤ —Å–∏—Å—Ç–µ–º—É.
"""
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üîê –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è", callback_data="login")]
        ])
    elif user.get("status") == UserStatus.ANONYMOUS:
        login_token = user.get("login_token", "")
        provider = user.get("provider", "code")

        code = ""
        if login_token in auth_service.login_tokens:
            token_data = auth_service.login_tokens[login_token]
            if token_data.get("code"):
                code = token_data["code"]

        if provider == "code":
            code_text = f"<b>–ö–æ–¥: <code>{code}</code></b>" if code else ""
            text = f"""
üîê <b>–û–∂–∏–¥–∞–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ –∫–æ–¥</b>

–î–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –≤ –≤–µ–±-–∫–ª–∏–µ–Ω—Ç–µ:

{code_text}

–ù–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å" –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞ –∫–æ–¥–∞.
"""
        else:
            provider_name = "GitHub" if provider == "github" else "–Ø–Ω–¥–µ–∫—Å ID" if provider == "yandex" else provider
            text = f"""
üîê <b>–û–∂–∏–¥–∞–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ {provider_name}</b>

–î–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≤—Ö–æ–¥ –≤ –±—Ä–∞—É–∑–µ—Ä–µ.

–ù–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å" –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.
"""
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å", callback_data=f"check_auth_{login_token}")],
            [InlineKeyboardButton(text="üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="login")]
        ])
    else:
        user_email = user.get("email", "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")
        text = f"""
‚úÖ <b>–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ {user_email}</b>

<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/tests ‚Äî —Å–ø–∏—Å–æ–∫ —Ç–µ—Å—Ç–æ–≤
/courses ‚Äî —Å–ø–∏—Å–æ–∫ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω
/profile ‚Äî –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å
/logout ‚Äî –≤—ã—Ö–æ–¥ –∏–∑ —Å–∏—Å—Ç–µ–º—ã

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.
"""
        kb = None

    await message.answer(text, reply_markup=kb)


@dp.message(Command("help"))
@rate_limit()
@safe_send_message
async def cmd_help(message: Message):
    help_text = """
üÜò <b>–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º</b>

<b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/start ‚Äî –Ω–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã
/help ‚Äî —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞
/status ‚Äî —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã

<b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è:</b>
/login ‚Äî –≤—Ö–æ–¥ —á–µ—Ä–µ–∑ –∫–æ–¥/GitHub/–Ø–Ω–¥–µ–∫—Å
/logout ‚Äî –≤—ã—Ö–æ–¥
/logout all=true ‚Äî –≤—ã—Ö–æ–¥ —Å–æ –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤

<b>–î–∏—Å—Ü–∏–ø–ª–∏–Ω—ã –∏ —Ç–µ—Å—Ç—ã:</b>
/courses ‚Äî —Å–ø–∏—Å–æ–∫ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω
/tests ‚Äî —Å–ø–∏—Å–æ–∫ —Ç–µ—Å—Ç–æ–≤
/starttest id ‚Äî –Ω–∞—á–∞—Ç—å —Ç–µ—Å—Ç

<b>–ü—Ä–æ—Ñ–∏–ª—å:</b>
/profile ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ

<b>–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/services ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Ä–≤–∏—Å–∞—Ö
/debug ‚Äî –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
/ping ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞
/echo ‚Äî —ç—Ö–æ-–∫–æ–º–∞–Ω–¥–∞
"""
    await message.answer(help_text)


@dp.message(Command("login"))
@rate_limit()
@safe_send_message
async def cmd_login(message: Message):
    """–ü–æ–∫–∞–∑ –≤—ã–±–æ—Ä–∞ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    chat_id = message.chat.id
    user = await get_user(chat_id)

    if user and user.get("status") == UserStatus.AUTHORIZED:
        await message.answer(f"‚úÖ <b>–í—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ {user.get('email')}</b>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /logout –¥–ª—è –≤—ã—Ö–æ–¥–∞.")
        return

    text = """
üîê <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:</b>

1. <b>GitHub</b> ‚Äî –≤—Ö–æ–¥ —á–µ—Ä–µ–∑ –∞–∫–∫–∞—É–Ω—Ç GitHub
2. <b>–Ø–Ω–¥–µ–∫—Å ID</b> ‚Äî –≤—Ö–æ–¥ —á–µ—Ä–µ–∑ –Ø–Ω–¥–µ–∫—Å
3. <b>Code</b> ‚Äî –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–æ–¥ (–≤–µ–±-–∫–ª–∏–µ–Ω—Ç)
"""
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîó GitHub", callback_data="login_github")],
        [InlineKeyboardButton(text="üîó –Ø–Ω–¥–µ–∫—Å ID", callback_data="login_yandex")],
        [InlineKeyboardButton(text="üî¢ Code", callback_data="login_code")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_auth")]
    ])

    await message.answer(text, reply_markup=kb)


@dp.message(Command("logout"))
@rate_limit()
@safe_send_message
async def cmd_logout(message: Message):
    chat_id = message.chat.id
    user = await get_user(chat_id)

    if not user:
        await message.answer("‚ùå <b>–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã</b>\n\n–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ /login.")
        return

    if user.get("status") != UserStatus.AUTHORIZED:
        await delete_user(chat_id)
        await message.answer("üö™ <b>–ü—Ä–æ—Ü–µ—Å—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø—Ä–µ—Ä–≤–∞–Ω</b>")
        return

    command_text = message.text or ""
    logout_all = "all=true" in command_text.lower()

    if logout_all:
        await message.answer("‚úÖ <b>–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —Å–æ –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤</b>")
    else:
        await message.answer("üö™ <b>–í—ã –≤—ã—à–ª–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã</b>")

    stats.remove_active_user(chat_id)
    await delete_user(chat_id)


@dp.message(Command("status"))
@rate_limit()
@safe_send_message
async def cmd_status(message: Message):
    chat_id = message.chat.id
    user = await get_user(chat_id)

    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if not user:
        user_status = "‚ùå <b>–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω</b>"
        user_details = ""
    elif user.get("status") == UserStatus.ANONYMOUS:
        user_status = "üü° <b>–û–∂–∏–¥–∞–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏</b>"
        provider = user.get("provider", "code")
        provider_name = {
            "github": "GitHub",
            "yandex": "–Ø–Ω–¥–µ–∫—Å ID",
            "code": "–∫–æ–¥"
        }.get(provider, provider)
        user_details = f"\nüîß –°–ø–æ—Å–æ–± –≤—Ö–æ–¥–∞: {provider_name}"
    else:
        user_status = "‚úÖ <b>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω</b>"
        email = user.get("email", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
        user_details = f"\nüìß Email: {email}"

    authorized_users = await get_all_authorized_users()
    active_users_count = len(authorized_users)
    commands_count = stats.commands_count

    redis_status = "üü¢ –æ–Ω–ª–∞–π–Ω" if redis_client.connected else "üî¥ –æ—Ñ—Ñ–ª–∞–π–Ω"

    text = f"""
üìä <b>–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã</b>

<b>–í–∞—à —Å—Ç–∞—Ç—É—Å:</b>
{user_status}{user_details}

<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
‚è∞ <b>–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è:</b> {current_time}
üë• <b>–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {active_users_count}
üìä <b>–í—ã–ø–æ–ª–Ω–µ–Ω–æ –∫–æ–º–∞–Ω–¥:</b> {commands_count}

<b>–°–µ—Ä–≤–∏—Å—ã:</b>
‚Ä¢ Redis ‚Äî {redis_status}
‚Ä¢ Telegram Bot ‚Äî üü¢ –æ–Ω–ª–∞–π–Ω

<b>–ú–æ–¥—É–ª–∏:</b>
‚Ä¢ Auth Service ‚Äî üü° –∑–∞–≥–ª—É—à–∫–∞
‚Ä¢ Core Service ‚Äî üü° –∑–∞–≥–ª—É—à–∫–∞
‚Ä¢ Web Client ‚Äî üü° –∑–∞–≥–ª—É—à–∫–∞
"""
    await message.answer(text)


@dp.message(Command("tests"))
@rate_limit()
@require_auth()
@safe_send_message
async def cmd_tests(message: Message, user: Dict):
    tests = await core_service.get_tests(user.get("access_token", ""))

    text = "üìö <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–µ—Å—Ç—ã</b>\n\n"
    buttons = []

    for test in tests:
        status = "üü¢" if test.get("active") else "üî¥"
        text += f"{status} <b>{test['name']}</b>\n"
        text += f"üìù {test['description']}\n"
        text += f"‚ùì –í–æ–ø—Ä–æ—Å–æ–≤: {test.get('questions_count', 0)}\n\n"

        if test.get("active"):
            buttons.append([
                InlineKeyboardButton(
                    text=f"‚ñ∂Ô∏è {test['name']}",
                    callback_data=f"start_test_{test['id']}"
                )
            ])

    if not buttons:
        text += "\nüòî <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤ –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è</b>"

    kb = InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None
    await message.answer(text, reply_markup=kb)


@dp.message(Command("courses"))
@rate_limit()
@require_auth()
@safe_send_message
async def cmd_courses(message: Message, user: Dict):
    text = """
üéì <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã</b>

1. <b>–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ</b>
   ‚Ä¢ –û—Å–Ω–æ–≤—ã –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è
   ‚Ä¢ –û–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
   ‚Ä¢ –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

2. <b>–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö</b>
   ‚Ä¢ SQL –∏ —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–µ –ë–î
   ‚Ä¢ NoSQL –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
   ‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤

3. <b>–í–µ–±-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞</b>
   ‚Ä¢ HTML/CSS/JavaScript
   ‚Ä¢ Backend —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
   ‚Ä¢ –§—Ä–µ–π–º–≤–æ—Ä–∫–∏

4. <b>DevOps</b>
   ‚Ä¢ Docker –∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–∞—Ü–∏—è
   ‚Ä¢ CI/CD
   ‚Ä¢ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
"""
    await message.answer(text)


@dp.message(Command("profile"))
@rate_limit()
@require_auth()
@safe_send_message
async def cmd_profile(message: Message, user: Dict):
    user_id = user.get("user_id", "")
    access_token = user.get("access_token", "")

    profile = await core_service.get_user_profile(access_token, user_id)

    text = f"""
üë§ <b>–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>

<b>–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>
üìß <b>Email:</b> {profile.get('email', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}
üë§ <b>–ò–º—è:</b> {profile.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}
üé≠ <b>–†–æ–ª—å:</b> {profile.get('role', 'student')}
üìÖ <b>–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:</b> {profile.get('created_at', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}

<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
‚úÖ <b>–ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤:</b> {profile.get('completed_tests', 0)}
üèÜ <b>–°—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª:</b> {profile.get('average_score', 0)}%

<b>–°—Ç–∞—Ç—É—Å:</b> üü¢ –ê–∫—Ç–∏–≤–µ–Ω
"""
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìä –ú–æ–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", callback_data="my_results")],
        [InlineKeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="settings")]
    ])

    await message.answer(text, reply_markup=kb)


@dp.message(Command("services"))
@rate_limit()
@safe_send_message
async def cmd_services(message: Message):
    text = """
üß© <b>–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã</b>

<b>Telegram Bot (—ç—Ç–æ—Ç –º–æ–¥—É–ª—å)</b>
‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º —á–µ—Ä–µ–∑ Redis
‚Ä¢ –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–æ–≤
‚Ä¢ –¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏

<b>Auth Service</b>
‚Ä¢ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ GitHub, –Ø–Ω–¥–µ–∫—Å ID, Code
‚Ä¢ –í—ã–¥–∞—á–∞ JWT —Ç–æ–∫–µ–Ω–æ–≤
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚Ä¢ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–æ–≤

<b>Core Service</b>
‚Ä¢ –õ–æ–≥–∏–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ—Ü–µ–Ω–∫–∏
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞–º–∏ –∏ —Ç–µ—Å—Ç–∞–º–∏
‚Ä¢ –•—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –∏ –¥–æ—Å—Ç—É–ø–æ–≤

<b>Web Client</b>
‚Ä¢ –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–∏—Å—Ç–µ–º—ã
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π
‚Ä¢ –°–æ–∑–¥–∞–Ω–∏–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤
‚Ä¢ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –æ—Ç—á–µ—Ç—ã

<b>–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö</b>
‚Ä¢ PostgreSQL ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
‚Ä¢ Redis ‚Äî –∫—ç—à –∏ —Å–µ—Å—Å–∏–∏
‚Ä¢ MongoDB ‚Äî –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –ª–æ–≥–∏
"""
    await message.answer(text)


@dp.message(Command("debug"))
@rate_limit()
@safe_send_message
async def cmd_debug(message: Message):
    chat_id = message.chat.id
    user = await get_user(chat_id)

    authorized_users = await get_all_authorized_users()

    text = f"""
üêõ <b>–û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</b>

<b>–°–∏—Å—Ç–µ–º–∞:</b>
‚Ä¢ Chat ID: <code>{chat_id}</code>
‚Ä¢ Redis: {"üü¢ –ø–æ–¥–∫–ª—é—á–µ–Ω" if redis_client.connected else "üî¥ –æ—Ñ—Ñ–ª–∞–π–Ω"}
‚Ä¢ –í—Ä–µ–º—è: {datetime.now().strftime("%H:%M:%S")}

<b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b>
‚Ä¢ –°—Ç–∞—Ç—É—Å: {user.get('status') if user else 'UNKNOWN'}
‚Ä¢ User ID: {user.get('user_id') if user else '–ù–µ—Ç'}
‚Ä¢ Email: {user.get('email') if user else '–ù–µ—Ç'}

<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(authorized_users)}
‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ –∫–æ–º–∞–Ω–¥: {stats.commands_count}
‚Ä¢ Login tokens: {len(auth_service.login_tokens)}
"""
    await message.answer(text)


@dp.message(Command("ping"))
@rate_limit()
@safe_send_message
async def cmd_ping(message: Message):
    await message.answer("üèì <b>Pong!</b>\n\nü§ñ –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.\n‚ö° –í—Å–µ —Å–∏—Å—Ç–µ–º—ã –≤ –Ω–æ—Ä–º–µ.")


@dp.message(Command("echo"))
@rate_limit()
@safe_send_message
async def cmd_echo(message: Message):
    text = message.text or ""
    if len(text) > 6:
        await message.answer(f"üì¢ <b>–≠—Ö–æ:</b>\n\n{text[6:]}")
    else:
        await message.answer("üì¢ <b>–ù–∞–ø–∏—à–∏—Ç–µ —á—Ç–æ-–Ω–∏–±—É–¥—å –ø–æ—Å–ª–µ /echo</b>\n\n–ü—Ä–∏–º–µ—Ä: <code>/echo –ü—Ä–∏–≤–µ—Ç, –º–∏—Ä!</code>")


# =========================
# CALLBACK HANDLERS
# =========================
@dp.callback_query(F.data == "login")
async def callback_login(callback: CallbackQuery):
    await callback.answer()
    await cmd_login(callback.message)


@dp.callback_query(F.data.startswith("login_"))
async def callback_login_provider(callback: CallbackQuery):
    provider = callback.data[6:]  # github, yandex, code
    chat_id = callback.from_user.id

    if provider not in ["github", "yandex", "code"]:
        await callback.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä")
        return

    user = await get_user(chat_id)
    if user and user.get("status") == UserStatus.AUTHORIZED:
        await callback.answer("‚úÖ –í—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã")
        return

    login_token = secrets.token_urlsafe(32)
    await set_user_anonymous(chat_id, login_token, provider)

    auth_url = await auth_service.generate_login_url(login_token, provider)

    provider_names = {
        "github": "GitHub",
        "yandex": "–Ø–Ω–¥–µ–∫—Å ID",
        "code": "–∫–æ–¥"
    }

    if provider == "code":
        code = auth_service.login_tokens[login_token]["code"]
        text = f"""
üîê <b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–æ–¥</b>

–î–ª—è –≤—Ö–æ–¥–∞ –≤ —Å–∏—Å—Ç–µ–º—É –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –≤ –≤–µ–±-–∫–ª–∏–µ–Ω—Ç–µ:

<b>–ö–æ–¥: <code>{code}</code></b>

‚è≥ <b>–ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç</b>

–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –∫–æ–¥–∞ –Ω–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å".
"""
    else:
        provider_name = provider_names[provider]
        text = f"""
üîê <b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ {provider_name}</b>

–î–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:

<a href="{auth_url}">–°—Å—ã–ª–∫–∞ –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ {provider_name}</a>

–ü–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å".
"""

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å", callback_data=f"check_auth_{login_token}")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_auth")]
    ])

    await callback.message.edit_text(text, reply_markup=kb, parse_mode=ParseMode.HTML)
    await callback.answer()


@dp.callback_query(F.data.startswith("check_auth_"))
async def callback_check_auth(callback: CallbackQuery):
    login_token = callback.data[11:]
    result = await auth_service.check_login_token(login_token)

    if not result:
        await callback.answer("‚ùå –¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏—Å—Ç–µ–∫")
    elif result.get("status") == "pending":
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ - –∏–º–∏—Ç–∏—Ä—É–µ–º —Ä—É—á–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å Auth Service
        confirmed = await auth_service.simulate_auth_confirmation(login_token)
        if confirmed:
            # –°–æ–∑–¥–∞–µ–º —Ñ–µ–π–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_id = f"user_{secrets.token_hex(8)}"
            email = f"user_{login_token[:8]}@example.com"
            access_token = f"access_{secrets.token_hex(16)}"
            refresh_token = f"refresh_{secrets.token_hex(16)}"

            await set_user_authorized(
                callback.from_user.id,
                access_token,
                refresh_token,
                user_id,
                email
            )

            await callback.answer("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!")
            await callback.message.edit_text(
                f"‚úÖ <b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {email}",
                reply_markup=None
            )
        else:
            await callback.answer("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤—Ö–æ–¥–∞")
    elif result.get("status") == "granted":
        user_data = result.get("user", {})
        access_token = result["access_token"]
        refresh_token = result["refresh_token"]

        await set_user_authorized(
            callback.from_user.id,
            access_token,
            refresh_token,
            user_data.get("id"),
            user_data.get("email")
        )

        await callback.answer("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!")
        await callback.message.edit_text(
            f"‚úÖ <b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {user_data.get('email')}",
            reply_markup=None
        )


@dp.callback_query(F.data == "cancel_auth")
async def callback_cancel_auth(callback: CallbackQuery):
    chat_id = callback.from_user.id
    await delete_user(chat_id)
    await callback.answer("‚ùå –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
    await callback.message.edit_text("üö™ <b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞</b>", reply_markup=None)


@dp.callback_query(F.data.startswith("start_test_"))
@require_auth()
async def callback_start_test(callback: CallbackQuery, user: Dict):
    try:
        test_id = int(callback.data[11:])
        await callback.answer(f"üöÄ –ù–∞—á–∏–Ω–∞–µ–º —Ç–µ—Å—Ç #{test_id}")

        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ç–µ—Å—Ç–∞
        await callback.message.answer(f"üß™ <b>–ù–∞—á–∏–Ω–∞–µ–º —Ç–µ—Å—Ç #{test_id}</b>\n\n–°–∫–æ—Ä–æ –∑–¥–µ—Å—å –±—É–¥—É—Ç –≤–æ–ø—Ä–æ—Å—ã...")

    except ValueError:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID —Ç–µ—Å—Ç–∞")


# =========================
# BACKGROUND TASK - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø (–Ω–µ –∞–≤—Ç–æ—Ä–∏–∑—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
# =========================
async def check_anonymous_users_task():
    """–¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ anonymous –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - —Ç–æ–ª—å–∫–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
    while True:
        try:
            keys = await redis_client.keys("user:*")
            for key in keys:
                data = await redis_client.get(key)
                if data:
                    user = json.loads(data)
                    if user.get("status") == UserStatus.ANONYMOUS:
                        login_token = user.get("login_token")
                        if login_token:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—Ç–µ–∫ –ª–∏ —Ç–æ–∫–µ–Ω (–±–æ–ª—å—à–µ 5 –º–∏–Ω—É—Ç)
                            created_at_str = user.get("created_at")
                            if created_at_str:
                                try:
                                    created_at = datetime.fromisoformat(created_at_str)
                                    if (datetime.utcnow() - created_at).seconds > 300:  # 5 –º–∏–Ω—É—Ç
                                        # –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                                        await delete_user(user.get("chat_id"))
                                except:
                                    pass
        except Exception as e:
            logger.error(f"Error in check_anonymous_users_task: {e}")

        await asyncio.sleep(30)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥


# =========================
# MESSAGE HANDLER
# =========================
@dp.message()
@rate_limit()
@safe_send_message
async def handle_message(message: Message):
    text = message.text or ""
    if not text.startswith('/'):
        await message.answer("ü§ñ <b>–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</b>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.")


# =========================
# MAIN
# =========================
async def main():
    logger.info("ü§ñ Telegram bot starting...")

    await redis_client.connect()

    background_task = asyncio.create_task(check_anonymous_users_task())

    logger.info("üöÄ Bot is ready!")

    try:
        await dp.start_polling(bot, skip_updates=True)
    except KeyboardInterrupt:
        logger.info("üëã Bot stopped by user")
    finally:
        background_task.cancel()


if __name__ == "__main__":
    asyncio.run(main())